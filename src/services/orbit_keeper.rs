//! Orbit Keeper RPC client for fetching claimable data from VAULT contract
//!
//! Connects to Orbit chain and calls getClaimableAcquisition/getClaimableDisposal
//! methods on the VAULT contract for keeper addresses.

use alloy::{
    primitives::Address,
    providers::{Provider, ProviderBuilder, RootProvider},
    sol,
    transports::http::{Client, Http},
};
use std::str::FromStr;
use std::time::Duration;
use tracing::{debug, error, info, warn};

// Discovers ALL vaults on-chain via Castle/Steward, then polls each vault.
// No hardcoded vault address - discovers dynamically like vendor/keeper do.

/// Orbit chain ID
const ORBIT_CHAIN_ID: u64 = 111222333;

/// Maximum retry attempts for RPC calls
const MAX_RETRIES: u32 = 3;

/// Base delay between retries (will be exponentially increased)
const RETRY_BASE_DELAY_MS: u64 = 1000;

// Define the VAULT contract interface using alloy's sol! macro
sol! {
    #[sol(rpc)]
    interface IVault {
        function getClaimableAcquisition(address keeper) external view returns (uint128, uint128);
        function getClaimableDisposal(address keeper) external view returns (uint128, uint128);
    }
}

// Define the Steward interface for vault discovery (called via Castle proxy)
sol! {
    #[sol(rpc)]
    interface ISteward {
        function getVaultCount() external view returns (uint128);
        function getVault(uint128 index_id) external view returns (address);
    }
}

/// Discovered vault info
#[derive(Debug, Clone)]
pub struct DiscoveredVault {
    pub index_id: u128,
    pub vault_address: Address,
}

/// Result of fetching keeper claimable data
#[derive(Debug, Clone)]
pub struct KeeperClaimableResult {
    pub keeper_address: String,
    pub acquisition_value_1: u128,
    pub acquisition_value_2: u128,
    pub disposal_value_1: u128,
    pub disposal_value_2: u128,
    pub block_number: u64,
    pub block_timestamp: u64,
}

/// Error types for Orbit Keeper service
#[derive(Debug)]
pub enum OrbitKeeperError {
    ProviderError(String),
    ContractCallError(String),
    InvalidAddress(String),
    MaxRetriesExceeded(String),
}

impl std::fmt::Display for OrbitKeeperError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            OrbitKeeperError::ProviderError(msg) => write!(f, "Provider error: {}", msg),
            OrbitKeeperError::ContractCallError(msg) => write!(f, "Contract call error: {}", msg),
            OrbitKeeperError::InvalidAddress(msg) => write!(f, "Invalid address: {}", msg),
            OrbitKeeperError::MaxRetriesExceeded(msg) => {
                write!(f, "Max retries exceeded: {}", msg)
            }
        }
    }
}

impl std::error::Error for OrbitKeeperError {}

/// Orbit Keeper service for fetching claimable data
pub struct OrbitKeeperService {
    provider: RootProvider<Http<Client>>,
    castle_address: Address,
}

impl OrbitKeeperService {
    /// Create a new OrbitKeeperService
    ///
    /// # Arguments
    ///
    /// * `rpc_url` - Orbit RPC URL (e.g., "https://index.rpc.zeeve.net")
    /// * `castle_address_str` - Castle contract address on Orbit (Steward proxy)
    ///
    /// # Errors
    ///
    /// Returns error if URL is invalid, castle address is invalid, or connection fails
    pub async fn new(rpc_url: &str, castle_address_str: &str) -> Result<Self, OrbitKeeperError> {
        info!(rpc_url = %rpc_url, castle = %castle_address_str, "Initializing OrbitKeeperService");

        let provider = ProviderBuilder::new()
            .on_http(rpc_url.parse().map_err(|e| {
                OrbitKeeperError::ProviderError(format!("Invalid RPC URL: {}", e))
            })?);

        // Verify connection
        let chain_id = provider.get_chain_id().await.map_err(|e| {
            error!(error = %e, "Failed to connect to Orbit RPC");
            OrbitKeeperError::ProviderError(format!("Connection failed: {}", e))
        })?;

        if chain_id != ORBIT_CHAIN_ID {
            warn!(
                expected = ORBIT_CHAIN_ID,
                actual = chain_id,
                "Chain ID mismatch - expected Orbit chain"
            );
        }

        let castle_address = Address::from_str(castle_address_str).map_err(|e| {
            OrbitKeeperError::InvalidAddress(format!("Invalid CASTLE_ADDRESS '{}': {}", castle_address_str, e))
        })?;

        info!(
            chain_id = chain_id,
            castle_address = %castle_address,
            "OrbitKeeperService initialized successfully"
        );

        Ok(Self {
            provider,
            castle_address,
        })
    }

    /// Discover all vaults on-chain via Steward.getVaultCount() + getVault()
    ///
    /// ITP IDs start at 10000 (generated by bridge-node as 10000 + nonce).
    /// Iterates from 10000..10000+count to find all vault addresses.
    pub async fn discover_vaults(&self) -> Result<Vec<DiscoveredVault>, OrbitKeeperError> {
        let steward = ISteward::new(self.castle_address, &self.provider);

        let count_result = steward.getVaultCount().call().await.map_err(|e| {
            OrbitKeeperError::ContractCallError(format!("getVaultCount failed: {}", e))
        })?;

        let vault_count = count_result._0;
        info!(vault_count = vault_count, "Discovered vault count from Steward");

        let mut vaults = Vec::new();
        let base_id: u128 = 10000;

        for i in 0..vault_count {
            let index_id = base_id + i;
            match steward.getVault(index_id).call().await {
                Ok(result) => {
                    let vault_address = result._0;
                    if vault_address != Address::ZERO {
                        debug!(
                            index_id = index_id,
                            vault_address = %vault_address,
                            "Discovered vault"
                        );
                        vaults.push(DiscoveredVault {
                            index_id,
                            vault_address,
                        });
                    }
                }
                Err(e) => {
                    warn!(
                        index_id = index_id,
                        error = %e,
                        "Failed to get vault address, skipping"
                    );
                }
            }
        }

        info!(
            discovered = vaults.len(),
            total = vault_count,
            "Vault discovery complete"
        );

        Ok(vaults)
    }

    /// Get claimable acquisition values for a keeper on a specific vault
    pub async fn get_claimable_acquisition(
        &self,
        vault_address: Address,
        keeper: &str,
    ) -> Result<(u128, u128), OrbitKeeperError> {
        let keeper_address = Address::from_str(keeper)
            .map_err(|e| OrbitKeeperError::InvalidAddress(format!("Invalid keeper: {}", e)))?;

        self.with_retry("getClaimableAcquisition", || async {
            let vault = IVault::new(vault_address, &self.provider);
            let result = vault
                .getClaimableAcquisition(keeper_address)
                .call()
                .await
                .map_err(|e| {
                    OrbitKeeperError::ContractCallError(format!(
                        "getClaimableAcquisition failed: {}",
                        e
                    ))
                })?;

            Ok((result._0, result._1))
        })
        .await
    }

    /// Get claimable disposal values for a keeper on a specific vault
    pub async fn get_claimable_disposal(
        &self,
        vault_address: Address,
        keeper: &str,
    ) -> Result<(u128, u128), OrbitKeeperError> {
        let keeper_address = Address::from_str(keeper)
            .map_err(|e| OrbitKeeperError::InvalidAddress(format!("Invalid keeper: {}", e)))?;

        self.with_retry("getClaimableDisposal", || async {
            let vault = IVault::new(vault_address, &self.provider);
            let result = vault
                .getClaimableDisposal(keeper_address)
                .call()
                .await
                .map_err(|e| {
                    OrbitKeeperError::ContractCallError(format!(
                        "getClaimableDisposal failed: {}",
                        e
                    ))
                })?;

            Ok((result._0, result._1))
        })
        .await
    }

    /// Get all claimable data for a keeper on a specific vault
    ///
    /// # Arguments
    ///
    /// * `vault_address` - The vault contract address to poll
    /// * `keeper` - Keeper address in 0x format
    ///
    /// # Returns
    ///
    /// KeeperClaimableResult with all four values and block timestamp
    pub async fn get_claimable_data(
        &self,
        vault_address: Address,
        keeper: &str,
    ) -> Result<KeeperClaimableResult, OrbitKeeperError> {
        debug!(keeper = %keeper, vault = %vault_address, "Fetching claimable data");

        // Get current block for timestamp
        let block = self.provider.get_block_number().await.map_err(|e| {
            OrbitKeeperError::ProviderError(format!("Failed to get block number: {}", e))
        })?;

        // Get block details to extract timestamp using raw JSON-RPC
        let block_timestamp: u64 = {
            let params = serde_json::json!([format!("0x{:x}", block), false]);
            let response: serde_json::Value = self.provider
                .client()
                .request("eth_getBlockByNumber", params)
                .await
                .map_err(|e| {
                    OrbitKeeperError::ProviderError(format!("Failed to get block details: {}", e))
                })?;

            // Parse timestamp from hex string
            response["timestamp"]
                .as_str()
                .and_then(|s| u64::from_str_radix(s.trim_start_matches("0x"), 16).ok())
                .unwrap_or(0)
        };

        let (acq_1, acq_2) = self.get_claimable_acquisition(vault_address, keeper).await?;
        let (disp_1, disp_2) = self.get_claimable_disposal(vault_address, keeper).await?;

        let result = KeeperClaimableResult {
            keeper_address: keeper.to_string(),
            acquisition_value_1: acq_1,
            acquisition_value_2: acq_2,
            disposal_value_1: disp_1,
            disposal_value_2: disp_2,
            block_number: block,
            block_timestamp,
        };

        debug!(
            keeper = %keeper,
            vault = %vault_address,
            acq_1 = acq_1,
            acq_2 = acq_2,
            disp_1 = disp_1,
            disp_2 = disp_2,
            block_number = block,
            block_timestamp = block_timestamp,
            "Fetched claimable data successfully"
        );

        Ok(result)
    }

    /// Execute an async operation with exponential backoff retry
    async fn with_retry<T, F, Fut>(&self, operation: &str, f: F) -> Result<T, OrbitKeeperError>
    where
        F: Fn() -> Fut,
        Fut: std::future::Future<Output = Result<T, OrbitKeeperError>>,
    {
        let mut attempts = 0;
        let mut last_error = None;

        while attempts < MAX_RETRIES {
            match f().await {
                Ok(result) => return Ok(result),
                Err(e) => {
                    attempts += 1;
                    last_error = Some(e);

                    if attempts < MAX_RETRIES {
                        let delay = Duration::from_millis(RETRY_BASE_DELAY_MS * (1 << attempts));
                        warn!(
                            operation = %operation,
                            attempt = attempts,
                            max_attempts = MAX_RETRIES,
                            delay_ms = delay.as_millis(),
                            "RPC call failed, retrying..."
                        );
                        tokio::time::sleep(delay).await;
                    }
                }
            }
        }

        error!(
            operation = %operation,
            attempts = attempts,
            "Max retries exceeded"
        );

        Err(OrbitKeeperError::MaxRetriesExceeded(format!(
            "{}: {}",
            operation,
            last_error
                .map(|e| e.to_string())
                .unwrap_or_else(|| "Unknown error".to_string())
        )))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_address_parsing() {
        // Castle and vault addresses come from env at runtime; verify parsing works
        let valid = Address::from_str("0x1409a0ce0770e6e428add1ef73c6d872319557d8");
        assert!(valid.is_ok());
        let invalid = Address::from_str("not-an-address");
        assert!(invalid.is_err());
    }

    #[test]
    fn test_keeper_claimable_result_debug() {
        let result = KeeperClaimableResult {
            keeper_address: "0x1234".to_string(),
            acquisition_value_1: 100,
            acquisition_value_2: 200,
            disposal_value_1: 50,
            disposal_value_2: 75,
            block_number: 12345,
            block_timestamp: 1700000000,
        };
        assert_eq!(result.keeper_address, "0x1234");
        assert_eq!(result.acquisition_value_1, 100);
        assert_eq!(result.block_number, 12345);
    }

    #[test]
    fn test_discovered_vault() {
        let vault = DiscoveredVault {
            index_id: 10000,
            vault_address: Address::from_str("0x621f5f30d4902ab75d8bd50820cc0a09cc563559").unwrap(),
        };
        assert_eq!(vault.index_id, 10000);
        assert_ne!(vault.vault_address, Address::ZERO);
    }

    #[test]
    fn test_error_display() {
        let err = OrbitKeeperError::ProviderError("test".to_string());
        assert!(err.to_string().contains("Provider error"));
    }
}
